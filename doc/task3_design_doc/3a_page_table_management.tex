\section{Page Table Management}

\subsection{Data Structures}

% Copy here the declaration of each new or changed `struct' or
% `struct' member, global or static variable, `typedef', or
% enumeration.  Identify the purpose of each in 25 words or less.

\subsection{Algorithms - Frame Locating}

% In a few paragraphs, describe your code for locating the frame,
% if any, that contains the data of a given page.

During a page fault, we find which segment a page is in (this is necessary
because the segment struct contains metadata which is required for this locating
algorithm), and then we check whether the page has previously been mapped. If it
has, then we will find a struct that tells us whether the page lies in swap or
not. It also tells us where in swap it lies if the page does currently reside in
swap.

If this struct cannot be found, then we can infer which page of the file the
faulting page resides in, from data stored in the segment (a struct file
pointer, the offset into the file that the segment begins at, etc.).

When requesting a new frame, we use the unchanged palloc\_get\_page function to
locate a free frame to use. If no frame is returned, then we evict some frame to
use (more details on this further down).

\subsection{Algorithms - Aliases of Accessed and Dirty bits}

% How does your code coordinate accessed and dirty bits between
% kernel and user virtual addresses that alias a single frame, or
% alternatively how do you avoid the issue?

We simply check the accessed and dirty bits of both, summing the number of bits
set for all aliases of a frame.

\subsection{Synchronization - Concurrent frame requests}

% When two user processes both need a new frame at the same time,
% how are races avoided?

The frame table has a lock, which is acquired inside the request\_frame
function when it does its work, and released before it returns. If two user
processes request a frame at the same time, then the second call blocks
until the first is finished.

\subsection{Rationale - Virtual-to-Physical Mappings}

% Why did you choose the data structure(s) that you did for
% representing virtual-to-physical mappings?

We chose to keep track of data about segments of user virtual pages,
corresponding to the code and data segments of the user executable, but also
allowing us to group the pages of every memory-mapped file, and the pages of the
stack together. This is memory efficient compared to keeping the same data
multiple times in a struct corresponding to each user virtual page, as a lot of
redundant data will need to be stored. The only additional requirement is that
segments must keep a hash table of the pages that have been mapped previously to
frames within it.

Pages are either on a file, in swap, or in memory, and during a page fault, we
only need to know whether it is in a file, or in swap (since it clearly isn't in
memory). Since only pages that have already been mapped can be swapped out, it
is sufficient to simply store some small amount of data on mapped pages to
indicate whether they are in swap, and if they are, where they are in swap.

Using a list to keep track of segments means iterating over the list during each
page fault, which is somewhat slow. It works fast enough in practice however,
and we didn't want to use too much time implementing a faster data structure.
