\part{Page Table Management}

\section{Data Structures}

% Copy here the declaration of each new or changed `struct' or
% `struct' member, global or static variable, `typedef', or
% enumeration.  Identify the purpose of each in 25 words or less.

\section{Algorithms}

% In a few paragraphs, describe your code for locating the frame,
% if any, that contains the data of a given page.

% How does your code coordinate accessed and dirty bits between
% kernel and user virtual addresses that alias a single frame, or
% alternatively how do you avoid the issue?

We simply check the accessed and dirty bits of both, summing the number of bits
set for all aliases of a frame.

\section{Synchronization}

% When two user processes both need a new frame at the same time,
% how are races avoided?

The frame table has a lock, which is acquired inside the request\_frame
function when it does its work, and released before it returns. If two user
processes request a frame at the same time, then the second call blocks
until the first is finished.

\section{Rationale}

% Why did you choose the data structure(s) that you did for
% representing virtual-to-physical mappings?

The pagedir takes care of actually mapping virtual addresses to physical
addresses, so our data structures do not do so. Our supplementary page table
maps virtual user addresses to supplementary page table entries, via a hash
table. This provides constant time lookup of virtual addresses. The only
time we are not simply looking up an address in some table is during page
eviction, for which we have a list of all allocated frames to iterate over.
